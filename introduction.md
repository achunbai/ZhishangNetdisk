# 客户端建立

1. 按照创建项目的内容进行创建项目，暂且命名为“智商网盘”("ZhishagnNetDisk")
2. 在编译器配置文件中添加网络模块
  - 之前选择了编译器为qmake，所以需要在.pro文件中添加
  - 找到首行，修改为 `QT  += core gui network`(新增`network`模块)
3. 读取配置文件，添加配置文件的方法下面会提及
  - 目前配置文件按照行来区分不同的数据
  - 需要先读取配置文件
    - 判断换行符并用换行符进行分割
      - 缺点：只能针对某种特定的系统，如果更换了系统，则可能出现问题
      - Windows中，换行符为`\r\n`
      - MacOS中，换行符为`\n`
    - 使用`QTextStream`处理配置文件，会自动识别换行符问题，这样换行符就统一为了`\n`
4. 定义属性，在类中添加私有类型的成员变量
  - IP
  - 端口号
  - socket(需要添加`<QTcpSocket>`头文件)，套接字用于和服务器进行通信
5. 使用`socket`连接服务器
  - 定义显示连接成功的槽函数，打印链接成功信息至控制台
  - 构造函数中连接刚定义的槽函数和连接成功的信号`QTcpSocket::connected`
    - 需要使用`connect`函数进行连接，函数用法如下
    - `[static] QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)`
  - 使用`socket`连接服务器
    - 通过`connectToHost`连接，给出IP和端口号
    - 注意IP需要转换，将`QString`转换为`QHostAddress`类型，再作为函数的参数传入
    - `QHostAddress`用来将地址字符串转换为可以识别的IP地址(`QHostAddress`类型)
6. 部分提示消息通过`QMessageBox`展示
  - `QMessageBox::critical`是Qt库中的一个静态函数，用于显示一个错误消息对话框。这个函数接受三个参数：
    - `this`：这一个指向父窗口的指针。如果在一个成员函数中调用`QMessageBox::critical`，通常会使用this作为父窗口。这样，当消息框被显示时，它会阻止用户与父窗口进行交互，直到用户关闭消息框。
    - "打开配置"：这是消息框的标题。
    - "配置文件格式错误"：这是在消息框中显示的文本。
    - 所以，`QMessageBox::critical(this, "打开配置", "配置文件格式错误");`这行代码的意思是，显示一个错误消息框，标题为"打开配置"，内容为"配置文件格式错误"。

# 配置文件设置

1. 新建资源文件
  - 右击项目 -> 添加文件 -> Qt Resource File -> 注意文件名不添加后缀
2. 设置前缀
  - 前缀是对资源文件的一个分类，因为需要设置的是配置文件，前缀设置为了`/Config`
3. 添加配置文件
4. 修改配置文件
  - 首行为IP
  - 第二行为端口号
  - 在本地实现，所以IP为本地环回地址`127.0.0.1`，端口任意高端口，设置为`11451`
5. 读取配置文件
  - 使用QFile类操作文件
  - 创建QFile实例，只读模式打开文件
  - 读取文件
    - 方案1：使用`QByteArray`读取文件，会导致不同系统之间出错
      - 使用`QByteArray`读取文件并转成`QString`类型
      - 按照`\r\n`拆分字符串
    - 方案2：使用`QTextStream`读取文件
      - 使用`QTextStream`读取文件并转成`QString`类型
      - `QTextStream`会自动识别换行符并自动将换行符转换为`\n`
      - 按照`\r`对字符串进行拆分
  - 使用`QStringList`存储每行数据
    - 判断文件内容是否多余两行
  - 关闭文件

# 服务器建立

1. 新建`Server`项目，按照客户端的流程，包含`network`，并加载配置文件
2. 监听客户端的连接
  - 使用`QTcpServer`调用`listen()`进行监听
    - 因为有多个客户端会连接到同一个服务器，所以需要重写某些函数，故需要定义一个自定义的类
    - 新建`ZhishangTcpServer`类，继承`QTcpServer`，实现单例模式
    - `Server`类的构造函数使用`ZhishangTcpServer`调用`listen()`
3. 处理客户端连接
  - 有客户端连接的时候`QTcpServer`会自动调用`incommingConnection`，输出连接成功并将客户端的Socket保存下来
    - 重写`incommingConnection`函数，输出连接成功
  - 因为客户端连接后，需要进行功能的实现，故需要定义一个自定义的类
  - 新建类`ZhishangTcpSocket`类，继承`QTcpSocket`
  - `ZhishangTcpServer`类中定义私有成员变量`ClientTcpSocketList`存储所有连接到该服务器的客户端Socket
  - 重写`incommingConnection`函数，添加将连接的客户端`ZhishangTcpSocket`放入列表

# 通信协议设计

通信协议中需要传输的数据单元为PDU，PDU（Protocol Data Unit）是协议数据单元的缩写，是网络通信中数据的最小传输单位。

**服务器在和客户端进行通信的时候可能会遇到幻包和脏包的情况**
- 客户端和服务器之间发送的数据可能不能只由一个数据包完整发送
- 如果内容过长，会对其进行拆分再发送
- 服务器和客户端需要知道对方发送的消息是否完整
- 如果一方在发送多条消息间隔时间过短，可能会造成另一方将多条消息读成一条消息的情况

**半包（Half-Packet）**：
- 半包是指一个完整的数据包被TCP拆分成两个或多个数据包进行发送。
- 这种情况通常是由于数据包的大小超过了TCP的最大传输单元（MTU）导致的。
- 接收方在接收到数据时，需要将这些被拆分的数据包重新组合成一个完整的数据包。

**粘包（Stick-Packet）**：
- 粘包是指多个数据包被TCP合并为一个数据包进行发送。
- 这种情况通常是由于网络的延迟或者数据包的大小小于TCP的最小传输单元导致的。
- 接收方在接收到数据时，需要将这个大的数据包拆分成多个原始的数据包。

**避免半包和粘包的方法**：
1. 标注数据长度（实际数据长度，协议总长度）
2. 隔开数据内容（柔性数据存大数据，先申请64位空间存储小数据，注意柔性数组放在最后）
3. 标注数据类型

可以定义一个PDU结构体来存储需要传输的数据

数据内容可以使用柔性数组来定义，柔性数组在声明时不占用空间，要存多少东西就需要额外申请多大的空间

## 协议设计

协议结构体，定义PDU，包含：
- PDU总长度`PDULen`
- 实际消息长度`MsgLen`
- 消息类型`MsgType`
- 参数（短消息）`ParaData`
- 消息内容（柔性数组）`Msg[]`

### 柔性数组

结构体中至少需要包含两个元素，一个是传输单元长度，便于读取，另一个就是消息内容，因为消息内容长度不确定，故使用固定长度的数组会造成使用上的不灵活以及空间的利用率降低。

柔性数组放在PDU的末尾，声明数组，但是不初始化其长度，结构体大小计算时不计算柔性数组的大小，使用的时候按需分配，所以需要针对柔性数组编写对应的建立函数。

### 流程

1. 新建C++类`ZhishangProtocol`
2. 定义结构体，以及PDU的初始化函数
3. 定义枚举类型，确定消息类型的枚举值
4. PDU初始化参数为实际消息长度，根据成都申请空间，初始化协议数据

## 客户端发送

客户端编辑用于实现功能的ui界面，实现功能的测试

### 流程

1. ui界面
  - LineEdit，PushButton，按钮按下槽函数
2. 构建PDU
  - 从LineEdit中取出字符串，初始化一个PDU
  - 将字符串通过`memcpy`写入PDU
3. socket发送PDU
  - `ClientSocket`调用`write`函数
4. 释放PDU
  - 若使用`malloc`创建，则使用`free`释放
  - 若使用`new`创建，则使用`delete`释放

### 创建槽函数

1. 在UI设计界面中右击按钮 -> 转到槽函数
2. 手动声明槽函数，在构造函数中使用`connect`进行连接

## 服务器接收

服务器连接`readyRead`信号，使用`ZhishangTcpSocket`调用`read()`函数

### 流程

1. `ZhishangTcpSocket`类定义槽函数`ReceiveMsg`
2. `ZhishangTcpSocket`构造函数中使用`connect`连接信号槽
3. 编写`ReceiveMsg`槽函数
  - 使用`read`先读取协议总长度，开头协议总长度的大小已知
  - 计算实际消息长度（使用总长度减去PDU结构长度）
  - 初始化一个PDU，得到指针
  - `read`函数读取PDU剩下的内容，写入rPDU中
  - 此时读取的指针已经偏移到协议总长度之后，所以后续读取的内容需要减去之前读取的协议总长度进行读取，获得完整的PDU

# 注册登录功能设计

## 数据库表设计

### 用户信息表——user_info

| 字段 | 类型 | 约束条件 | 描述 |
| ---- | ---- | ---- | ---- |
| id | int | 主键，自增 | 用户ID |
| username | varchar(24) | 非空，唯一 | 用户名 |
| passwd | varchar(32) | 非空 | 密码 | 密码 |
| isOnline | tinyint(1) | 默认为0，离线| 是否在线 |

```SQL
create table if not exists user_info(
    id int primary key auto_increment ,
    username varchar(24) unique not null ,
    isOnline tinyint(1) default 0
);
```

### 用户好友关系表——friend_info

| 字段 | 类型 | 约束条件 | 描述 |
| ---- | ---- | ---- | ---- |
| id | int | 主键，自增 | 关系ID |
| user_id | int | 外键 | 用户ID |
| friend_id | int | 外键 | 好友ID |

```SQL
create table if not exists friend_info(
    id int primary key auto_increment ,
    user_id int ,
    friend_id int ,
    constraint u_id foreign key (user_id) references user_info(id) ,
    constraint f_id foreign key (friend_id) references user_info(id)
);
```

## 连接数据库

1. server项目在编译器配置文件中添加sql模块(.pro文件)
2. 创建新的数据库操作类`DatabaseOperate`，继承`QObject`类
  - 实现单例模式
3. `DatabaseOperate`类中定义`QSqlDatabase`类型的私有税局哭对象`MySQLDatabase`
4. 构造函数中通过`QSqlDatabase::addDatabase("QMYSQL")`构造`MySQLDatabase`，析构函数中关闭`MySQLDatabase`
5. 定义数据库连接函数`ConnectDB`，配置苏句酷并连接
6. 一定要先添加数据库驱动文件，编译后添加

## 客户端登录界面设计

简单输入用户名，密码，增加两个按钮，一个是注册，一个是登录

输入用`QLineEdit`控件，密码需设置`echoMode`属性，这个属性决定了用户输入的文本应该如何显示：
1. `QLineEdit::Normal`：这是默认模式，在这种模式下，用户输入的文本会正常显示。
2. `QLineEdit::NoEcho`：在这种模式下，用户输入的文本不会显示。
3. `QLineEdit::Password`：在这种模式下，用户输入的文本会被替换为星号（*）或者其他的密码字符。
4. `QLineEdit::PasswordEchoOnEdit`：在这种模式下，当用户正在输入时，文本会正常显示，当用户完成输入后，文本会被替换为密码字符。

## 注册

客户端发送请求 -> 服务器接受请求 -> 用户名和密码放入数据库 -> 服务器返回成功或者失败 -> 客户端接受返回值

1. 客户端发送请求
  1. 协议中添加注册的请求和响应类型
  2. 槽函数获取用户名和密码
  3. 用户名和密码放入pdu发给服务器
    - 用户名和密码相对较短，可以对其进行限制然后放入到ParaData中
  4. 创建注册按钮槽函数，获取用户名和密码
  5. 用户名和密码放入ParaData，类型放入MsgType，发送给服务器
2. 服务器接收并处理注册请求，响应给客户端
  1. 接受消息函数，判断对应类型，调用对应函数进行处理
  2. 数据库操作类添加执行注册功能的函数ProcessRegister，参数为用户名和密码，构建SQL语句并执行
  3. 从PDU取出用户名和密码，调用ProcessRegister
  4. 构建PDU，把响应结果发送给客户端

## 登录

1. 客户端发送请求
  1. 协议中添加登录的请求和响应类型
  2. 客户端的登录按钮槽函数，构建pdu并发送
2. 服务器接收并处理请求，响应给客户端
  1. 数据库类新增处理登录函数，定义一个属性存储用户名
  2. 接收消息函数处理登录，定义一个属性存储登录名
  3. 构建pdu，发送给客户端是否登陆成功
3. 客户端接受并展示响应结果，根据响应类型和响应结果显示内容

# 处理客户端关闭

当前用户登录状态置0：`socket`断开连接发出`disconnected`信号，使用信号槽处理
  1. 数据库操作类中新增离线处理函数，将指定用户的`isOnline`状态置0
  2. `TcpSocket`中定义处理下线槽函数，连接`disconnected`信号
  3. 在槽函数中调用数据库离线处理函数
下线的`socket`从接收`socket`列表中移除：通过信号槽通知`TcpServer`移除
  1. `TcpSocket`类中定义一个下线的信号，通过处理下线的槽函数发出信号
  2. 在`TcpServer`中定义槽函数，连接信号和槽
  3. 槽函数中将下线用户的socket移除
  4. 遍历测试移除是否成功

## 界面跳转

1. 首页设置为单例模式
2. 登陆成功后创建首页实例并展示界面，隐藏登录页

# 功能

## 查找好友

- 客户端槽函数发送请求
  - 协议中添加查找用户请求和响应类型
  - 创建一个输入框获取用户输入的用户名
  - 用户名放入pdu然后发送给服务器
- 服务器接收并处理请求
  - 数据库操作类新增一个查找用户的函数，-1代表不存在，0代表不在线，1代表在线
  - 接收消息函数调用查找用户的函数，得到结果，放入ParaData中
  - 构建pdu，将结果返回给客户端
- 客户单处理返回的消息并展示结果，根据响应类型进行处理

## 在线用户列表

- 客户端槽函数发送请求
  - 协议中添加获取在线用户列表请求和响应类型
  - 在线用户列表槽函数发送请求
  - 展示在线用户列表界面
- 服务器接收并处理请求
  - 数据库操作类新增一个获取在线用户列表的函数，结果放入QStringList中
  - 接收消息函数调用查找在线用户列表的函数，得到结果，结果放入pdu的Msg中
  - 构建pdu，将结果返回给客户端
- 客户单处理返回的消息并展示结果，根据响应类型进行处理
  - 在OnlineUsers类中新增用户名放入列表框中的函数，参数为服务器返回的QStringList
  - pdu中取出用户名放入一个QStringList中，调用之前新增的函数

## 添加好友

需要两个客户端，一个是当前用户的客户端（Current），另一个是目标用户的客户端（Target）
1. Current向服务器发送添加好友请求
  1. 在线用户界面双击转到槽函数，或者直接在查找好友界面查找用户
  2. 槽函数获取当前登录用户名和目标用户名
    - 登录名在登录的时候需要作为成员变量保存下来
    - 在线用户入口目标用户名可以通过`item->text`获取
    - 查找用户直接从服务器返回的数据包中读取
  3. 构建PDU，发送给服务器
2. 服务器查询Target是否满足添加好友条件，满足条件转发给Target
  1. `ZhishangTcpServer`定义转发函数
    - 参数为目标用户名和pdu
    - 遍历socket列表找到用户名为Target的socket并发送
  2. 数据库操作类定义添加好友的函数
    - 查询是否已经是好友和是否在线
  3. 调用数据库操作函数添加好友，根据结果判断是否需要转发给Target
  4. 结果响应给Current，弹窗展示
  5. Target弹窗，询问是否统一添加好友请求
    - 数据库操作类添加同意添加好友请求
    - 消息处理类调用同意添加好友函数
    - 相应给Target，将结果转发给Current
  6. Current和Target都提示添加成功

## 刷新好友列表

1. 客户端向服务器发送请求
    1. 创建刷新好友列表的槽函数
    2. 协议中添加刷新好友列表协议
    4. 刷新好友功能封装乘一个函数，在friend构造函数和添加好友之后调用
    3. 将当前用户名添加到协议参数中传递给服务器
2. 服务器收到客户端发送的请求
    1. 数据库操作类添加对应的查询好友列表的函数
    2. 协议中添加刷新好友列表协议
    3. 查询到的结果添加到消息中传递给客户端，协议参数中添加是否成功
3. 客户端接受服务器传回的数据包
    1. 将数据包中的好友列表取出
    2. 在好友页面中添加写入好友列表函数
    3. 先清空，再写入到好友页面中的列表

## 删除好友

1. 客户端向服务器发送请求
    - 取好友列表框的当前项为删除的好友名
    - 协议中添加删除好友协议
    - 将当前用户名和需要删除的好友用户名放入PDU发送给服务器
2. 服务器收到客户端处理请求
    - 数据操作类添加删除好友的请求
        - 先判断是否是好友
        - 如果是好友开始删除
        - 不是好友返回值表示不是好友
    - socket调用该函数
        - 执行结果回传给客户端
        - 如果对方在线，传一份给对方
3. 客户端接收服务器传回的数据包
    - 客户端显示结果
    - 客户端更新好友列表

## 聊天

### UI

新建QT设计师界面类，包含TextEdit、PushButton和LineEdit

### 显示界面

1. 好友界面类创建一个聊天界面类指针的属性
    - 构造函数中创建
    - 析构函数中释放
2. 聊天按钮槽函数，判断是否在好友列表中选择了好友
3. 显示聊天界面
    - 聊天界面类中创建一个聊天好友名的属性，槽函数中将选择好友的名称赋值给该属性

### 聊天功能流程

1. 用户选择和好友的聊天
    - 在线开始聊天，离线提醒
    - 开始聊天之后显示页面，根据ID设置标题
2. 客户端发送
    - 发送按钮的槽函数，获取输入框的内容
    - 将聊天内容和双方用户名发送给服务器
    - 将自己说的内容和ID放入显示窗口
3. 服务器转发消息
    - 提取目标用户名和当前用户名
    - 转发消息给目标用户
4. 客户端显示内容
    - 显示聊天窗口
    - 在创建的聊天类中创建函数，更新聊天内容框
    - 将接收到来自对方的消息放入聊天框中
    - 更新聊天类中的聊天好友名属性

## 文件系统

### 创建文件夹

1. 用户路径初始化
    - 在服务器的对应运行路径创建用户路径文件夹，用于保存用户文件
        - 所有用户文件根目录在配置文件中初始化
    - 服务器和客户端新增配置，作为服务器和客户端的成员变量存下来
        - 服务器需要新增单例模式
        - 在服务器的socket中保存用户的根目录，客户端只存储相对路径
    - 在注册的时候服务器在运行路径中新建一个用户ID为路径的目录
    - 客户端定义属性，保存当前访问的路径
        - 在构造函数中初始化
        - 客户端保存相对路径
2. 客户端向服务器发送消息
    - 创建一个输入框，得到输入的目录名
    - 判断目录名是否合法，合法则将路径发送给服务器
3. 服务器接收并处理
    - 检查当前要创建的路径是否存在
    - 服务器判断收到的路径名是否合法
    - 拼接用户目录和创建的路径，返回值
4. 客户端显示响应结果

### 刷新文件

1. 客户端发送请求给服务器
    - 客户端封装刷新文件功能函数，方便后续其他地方调用
        - 函数需要获取当前需要刷新的路径
    - 刷新文件按钮的槽函数，Files的构造函数，创建文件夹等地方都需要被调用
2. 服务器处理请求
    - 定义一个结构体，存放文件信息，放入协议类中
        - 文件名
        - 文件类型
    - 获取指定路径下的文件
    - 发送给客户端
3. 客户端类型
    - 添加资源文件，分别是文件和文件夹的图标，放入资源文件中
    - Files中定义一个列表，保存当前路径下的文件信息
    - 客户端接收到的数据刷新到列表框中
        - 在Files类中定义更新文件列表函数
            - 清空后更新文件列表框
    - 接收消息处调用该函数

### 删除文件夹/文件

1. 客户端发送请求
    - 当前路径
    - 选中的文件夹
2. 服务器处理请求
    - 结合服务器中保存的当前用户根路径和传来的路径，拼接
    - 删除指定文件夹
    - 使用`dir.remove`
3. 客户端显示结果

### 进入文件夹

1. 客户端判断是否为文件夹，是文件夹的话更新当前路径
2. 向服务器发送刷新文件列表请求

### 返回上一级

1. 客户端当前路径去除掉最后的文件夹
    - 找到最后一个`/`，将其后面的所有内容删除
    - 判断当前路径是否为空，为空则为根目录，根目录不需要刷新
        - 用户的根路径存储在服务器中，防止客户端被修改从而访问到其他人的路径
2. 向服务器发送刷新文件列表请求

### 移动

1. 客户端点击“移动”
    - `Files`类中定义
        - 当前路径
        - 选择的项目名称
        - 目标路径
    - 将当前路径和选择的项目名称保存
    - 按钮文字变为“确定/取消”
2. 客户端点击“确定/取消“
    - 判断两个路径是否相同
        - 相同功能为取消
        - 不同保存当前路径为目标路径
    - 如果路径不同，则向服务器发送请求
        - 之前的文件/文件夹完整路径
        - 移动后的文件/文件夹的完整路径
3. 服务器处理客户端请求
    - 拼接完整路径
    - 移动文件/文件夹
    - 结果返回给客户端
4. 客户端处理返回的结果
    - 提示用户成功或者失败
    - 文件列表返回移动前的路径

## 解决粘包和半包

可以定义一个缓冲区来作为缓存，存放接收到的数据

1. 定义一个`QByteArray`类型的成员变量`buffer`，暂存`socket`内中的数据
2. 通过`readAll`读取socket中的全部数据
3. 将读取到的数据添加到`buffer`中
4. 循环处理buffer，判断buffer的大小是否能构建一个完整的PDU，读取协议长度
5. 构建PDU指针指向`buffer.data()`，读取`PDULen`，判断是否符合要求
6. 调用消息处理函数
7. 通过`remove`方法删除掉buffer中已经处理的数据

## 移动文件

1. 点击“移动文件”按钮
    - 获取当前路径和选中的文件名，保存
    - 提示用户选择需要移动到的目录
    - 文件名和完整路径作为file的成员变量保存
    - 按钮文字改为”确认/取消“
2. 点击“确认/取消”
    - 获取当前的路径
        - 判断是否选择了目录，选择了就移动到该目录下
        - 若没有选择目录，移动到当前目录下
    - 提示用户是否需要移动
    - 拼接完整路径
    - 将原路径和目标路径的长度放入`ParaData`中
    - 两个路径的值放在`Msg`中
    - 发送给服务器
3. 服务器处理

## 上传文件

1. 客户端发送上传请求
    - 通过文件选择窗口获取需要上传的文件路径
        - 路径作为file类的成员变量保存
    - 从路径中取出文件名
        - 将文件名、大小、路径发送给服务器
    - 每次上传一个文件
        - 定义一个是否在上传状态的file成员变量
2. 服务器处理上传请求
    - 消息处理函数定义文件属性记录值，方便分块上传
        - 上传文件对象
        - 上传文件大小
        - 已上传大小
        - 是否正在上传
    - 返回的结果
        - 已经有文件正在上传
        - 创建文件失败（用`open`函数）
        - 可以开始上传
    - 将接收的文件名和路径拼接，得到完整路径
        - 使用`open`函数创建文件
        - 更新关于上传的属性
        - 将结果返回给客户端
3. 客户端处理返回结果，将文件发送给服务器
    - File定义上传文件函数
        - 打开文件，构建PDU，循环读取文件放入Msg，发送PDU，关闭文件
        - 发送前和发送完成后更新上传状态的属性
    - 客户端接收消息处理调用文件上传函数
    - 一旦出错传回给服务器
4. 服务器接收文件
    - Msg写入文件，更新已接收文件大小的属性
    - 如果没有全部接受完不响应
    - 接受完成响应上传完成，关闭文件，更新上传状态
    - 一旦接收到出错消息，则删除服务器对应的文件

## 下载文件

1. 客户端发送下载文件请求
    - 先判断是不是文件夹，确保是文件
    - 弹出对话框选择保存文件位置
    - `Files`类中定义变量保存对应信息
        - 需要保存的文件对象
        - 保存的原始文件名
        - 是否在下载
        - 下载的总大小
        - 目前下载的大小
    - 创建对应的文件，只写
    - 将文件名和路径组合之后发给服务器
2. 服务器处理下载文件请求
    - 定义变量保存对应信息
        - 是否在上传
    - 组合接收到的路径名
    - 只读打开对应文件
        - 获取文件大小
    - 将所有的信息回传给客户端
3. 客户端处理
    - 若出错则删除下载的文件
    - 可以上传就调用上传的函数
4. 服务器接收可以下载请求
    - 向客户端传输文件
    - 如有出错则传错误
5. 客户端接收传输的文件
    - 出错就触发处理上传文件失败函数
    - 写入文件
    - 展示结果

## 分享文件

- UI界面
    - 好友列表框设置为多选
- 实现全选和取消已选函数
    - 遍历列表框元素，调用`setSelected`函数
- File界面的分享按钮槽函数
    - 判断是否选择了文件，记录选择的文件
    - 显示分享文件页面
    - 分享文件界面定义更新好友列表框的函数
        - 将`Friend`界面的好友列表框的内容给当前列表框
- 分享确定按钮的槽函数发送请求
    - 拼接当前路径和分享文件名为完整路径
    - 好友数量和当前用户名放入`ParaData`选择的好友名称和路径放入`Msg`
    - 发送请求给服务器
- 服务器转发给被分享的用户并相应
    - 取出当前用户名和好友数量
    - 遍历好友进行转发，转发发送者的名字和文件路径
    - 服务器响应给发送者
- 发送者客户端弹窗
    - 显示“文件已分享”
- 转发好友客户端处理是否接收
    - 从路径中取出用户名，弹窗询问用户是否接收
    - 如果用户选择接收文件，将文件保存在默认的文件夹中
    - 不接收返回给服务器
- 服务器处理
    - 若用户同意，则复制文件
    - 若拒绝，清空服务器保存的文件路径